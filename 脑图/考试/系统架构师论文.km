{"root":{"data":{"id":"1e854bd6cf48","created":1726367941,"text":"系统架构师论文"},"children":[{"data":{"id":"d46id8te7e00","created":1726367961353,"text":"软件架构风格","layout":null},"children":[{"data":{"id":"d46iicsd2g80","created":1726368361819,"text":"数据流体系架构风格","layout":null},"children":[{"data":{"id":"d4bte4v80qw0","created":1726906863113,"text":"批处理风格","note":"    每一部都是一个单独的程序，每一步必须在前一步结束之后才能开始，数据必须是完整的，以整体的方式进行传递\n优点：高吞吐量，适合大规模数据处理\n可以进行全局优化 充分利用资源\n易于编程，适合复杂计算\n\n缺点\n相应时间长，不适合处理实时需求\n不适合处理交互式应用\n需要处理大量数据时，需要大内存和计算资源\n"},"children":[]},{"data":{"id":"d4bte9cu4go0","created":1726906872885,"text":"管道过滤器风格","note":"数据流连接，一个步骤的输出是另一个步骤的输入。\n优点\n低延迟，可以处理实时应用\n可以按需处理数据，节约资源\n支持无限数据流，适用于流式处理数据\n\n缺点\n处理复杂逻辑需要额外编程\n不适合于离线数据分析和大规模批处理\n难以进行全局优化"},"children":[]}]},{"data":{"id":"d46iimqyyaw0","created":1726368383503,"text":"调用返回体系结构风格","layout":null},"children":[{"data":{"id":"d487hvgn97c0","created":1726540411809,"text":"主程序/子程序风格","note":"优点\n代码可以分解为小的可以复用的部分\n易于理解和维护\n支持代码重用，减少代码冗余\n\n缺点\n可能存在全局变量和共享状态，导致潜在的副作用\n难以处理负责的数据流和并发"},"children":[]},{"data":{"id":"d487i5m15400","created":1726540433903,"text":"面向对象体系风格","note":"优点\n封装性好\n继承和多态支持代码重用和扩展\n易于处理复杂的数据结构和关系\n缺点\n面向对象设计需要深思熟虑，不适合所有问题\n对象和方法的调用需要额外开销\n"},"children":[]},{"data":{"id":"d487idhok200","created":1726540451054,"text":"层次型体系风格","note":"优点\n分层结构清晰，易于维护和扩展\n支持模块化开发，不同层次可以独立开发测试\n适合构件大型系统和分布式系统\n缺点\n可能存在性能开销，因为数据要穿过多个层次\n需要精心设计层次和接口，否则会引入复杂性\n"},"children":[]},{"data":{"id":"d487iquvmow0","created":1726540480150,"text":"客户端/服务端 体系结构风格"},"children":[]}]},{"data":{"id":"d46iix8uldc0","created":1726368406351,"text":"以数据为中心的体系结构风格","layout":null},"children":[{"data":{"id":"d4btdhy6vuo0","created":1726906813227,"text":"仓库体系结构风格","note":"数据一致性\n高效的检索\n数据共享 \n缺点\n复杂性\n性能限制\n"},"children":[]},{"data":{"id":"d4btdrlto0o0","created":1726906834247,"text":"黑板体系结构风格","note":"分布式协作：黑板系统允许多个组件以分布式方式共同解决复杂问题。\n2. 灵活性：适用于需要多个专家领域知识的问题。\n3. 增量处理：问题可以被分解为多个子问题，逐步解决。\n\n缺点\n额外开销\n需要复杂的冲突解决策略"},"children":[]}]},{"data":{"id":"d46ij6lxwo80","created":1726368426734,"text":"虚拟机体系风格","layout":null},"children":[{"data":{"id":"d4btd72cc800","created":1726906789533,"text":"解释器风格","note":"使用解释器来执行源代码，而不是将代码编译成机器码\n 优点\n 跨平台性：解释器通常不依赖于底层硬件\n 灵活性：支持动态语言和运行时修改代码\n 易于调试和开发\n 缺点\n 性能较低\n 不适合高性能大规模应用\n "},"children":[]},{"data":{"id":"d4btdb85zzk0","created":1726906798592,"text":"规则系统","note":"基于规则的系统使用一系列规则和条件来决定程序的行为。\n\n灵活\n自动化 \n易于调试\n\n缺点\n复杂性：管理大量规则和条件变得复杂\n"},"children":[]}]},{"data":{"id":"d46ijbxs5pc0","created":1726368438334,"text":"独立构件体系结构风格","layout":null},"children":[{"data":{"id":"d4bt9adrgug0","created":1726906483297,"text":"进程通信体系风格","note":"构件是独立的进程，连接件是消息传递\n\n优点\n高度隔离，一个组件故障不会影响整个系统\n可以利用多核资源提高性能\n适用于大规模，分布式系统\n缺点\n开销大\n复杂性高\n"},"children":[]},{"data":{"id":"d4bt9xp5j3k0","created":1726906534052,"text":"事件系统体系结构风格","note":"基于事件的隐式调用风格的思想是构件不直接调用一个过程，而是触发或者广播一个或者多个事件。系统其他构件注册这个事件，事件触发，系统自动调用所有注册的过程。\n\n优点\n松散耦合，组件之间相互独立\n支持异步和非阻塞操作\n易于实现观察者模式和回调机制\n缺点\n难以追踪事件流\n处理复杂的业务模型时，事件驱动模型可能变得负责。"},"children":[]}]}]},{"data":{"id":"d46ijkkibts0","created":1726368457122,"text":"基于架构的软件开发方法","layout":null,"note":"架构与体系结构具有相同的含义"},"children":[{"data":{"id":"d4ejd0wnyzk0","created":1727183244900,"text":"需求分析阶段","note":"1 如何根据需求模型构件SA模型\n2 如何保证模型转换的可追踪性\n\n需求模型到SA模型，从问题空间到解空间"},"children":[]},{"data":{"id":"d4ejwydmm800","created":1727184806679,"text":"设计阶段","note":"SA的基本概念：即SA由哪些元素组成，这些元素之间按照何种原则组织\n"},"children":[{"data":{"id":"d4ejzlk9l3k0","created":1727185013874,"text":"SA的基本概念"},"children":[]},{"data":{"id":"d4ejzrqln400","created":1727185027318,"text":"体系结构描述语言","note":"支持构件，连接子，及其配置的描述yu'yan"},"children":[]},{"data":{"id":"d4ek0orthqw0","created":1727185099226,"text":"SA模型的多视图表示","note":"从不同的视角描述特定系统的体系结构，典型的视图包括4+1视图\n逻辑视图，进程视图，开发视图，物理视图+统一的场景\n"},"children":[]}]},{"data":{"id":"d4ek4hyp9s80","created":1727185397861,"text":"实现阶段","note":"1研究基于SA的开发过程支持，如项目组织结构，配置管理\n2寻求SA向实现过渡的途径，如将程序设计语言元素引入SA阶段，模型映射，构件组装，复用中间件平台等\n3研究基于SA的测试技术"},"children":[]},{"data":{"id":"d4ek9v2vd940","created":1727185818232,"text":"构件组装阶段","note":"在SA设计模型的指导下，可复用构件的组装可以在较高层次上实现系统，并能够提高系统实现的效率。\n研究内容主要两个方面\n1如何支持可复用构件的互联\n2在组装过程中，如何检测体系结构失配问题\n"},"children":[]},{"data":{"id":"d4ekbx177aw0","created":1727185979213,"text":"部署阶段","note":"SA对部署的作用如下：\n1提供高层的体系结构视图来描述部署阶段的软硬件模型\n2基于SA模型可以分析部署方案的质量属性，从而选择合理的部署方案。"},"children":[]},{"data":{"id":"d4ekd7yh7c80","created":1727186081357,"text":"后开发阶段","note":"SA研究主要围绕维护，演化，复用等方面来进行 "},"children":[]},{"data":{"id":"d4ekky3yezs0","created":1727186686834,"text":"ASBD","note":"基于架构的软件设计\n\n1设计元素\nASBD 是自顶向下，逐步细化的方法，系统被分解称为子系统和软件模板\n\n\n2 视角和视图\n3 用例和质量场景"},"children":[{"data":{"id":"d4ekpicpmig0","created":1727187044356,"text":" 基于体系的开发模型","note":"传统的软件开发过程被划分为问题定义，需求分析，软件设计，软件实现，软件测试\n基于体系的开发模型把软件过程划分为体系结构需求，设计，文档化，复审，实现 演化\n\n需求阶段：用例图和类图\n需求获取过程主要是定义开发人员必须要实现的软件功能\n，一般来源于三个方面，分别是系统的质量目标，系统的商业目标，系统开发人员的商业目标\n\n标识构件：1 生成类图 2对类进行分组 3 把类打包成构件\n\n架构需求评审\n"},"children":[{"data":{"id":"d4elh6etq000","created":1727189212559,"text":"体系结构设计","note":"1提出软件体系结构模型\n2将已经标识的构件映射到软件体系结构中\n3分析构件之间的相互作用\n4产生软件体系结构\n5设计评审"},"children":[]},{"data":{"id":"d4febqigfhc0","created":1727270598316,"text":"架构文档化","note":"对架构设计进行分析和整理，生成架构规格说明书和测试架构需求的质量设计说明说"},"children":[]},{"data":{"id":"d4feecw8a6o0","created":1727270803766,"text":"架构复审","note":"在主版本的软件架构分析之后，安排一次由外部人员参加的架构复审，架构复审主要判断架构是否能够满足需求，质量属性是否能够在架构中得以体现，层次是否清晰，模块划分是否合理。\n从而标识潜在的风险，及早发现架构设计中的缺陷和错误。"},"children":[]},{"data":{"id":"d4femdee2g00","created":1727271431778,"text":"体系结构实现","note":"以复审后的文档化的体系结构说明书为基础，以下步骤\n1分析与设计\n2构件实现\n3构件组装\n4系统测试"},"children":[]},{"data":{"id":"d4fep1soaxk0","created":1727271641613,"text":"架构演化阶段","note":"主要目的是解决系统开发过程中发生的需求变更问题。\n1需求变化归类\n2指定体系结构演化计划\n3修改，增加或者删除构件\n4更新构件的相互作用\n5构件的组装与测试\n6技术评审"},"children":[]}]}]}]},{"data":{"id":"d46ijsuirls0","created":1726368475142,"text":"基于构件的软件开发方法","layout":null},"children":[{"data":{"id":"d4fu4llbw0o0","created":1727315176815,"text":"定义","note":"体现了购买而不是重新构造"},"children":[]},{"data":{"id":"d4fu4xzncio0","created":1727315203802,"text":"特征","note":"可组装性：所有外部交互必须通过公开定义的接口进行\n可部署性：构件总是二进制形式的，能作为一个独立实体在平台上运行。\n文档化：用户通过文档来判断是否满足要求\n独立性：可以在无其它构件的情况下独立部署\n标准化：符合某种标准化的构件模型\t"},"children":[]},{"data":{"id":"d4m9e4vv5mg0","created":1727967600477,"text":"基于构件的开发过程","note":"1 系统需求概览\n2"},"children":[]}]},{"data":{"id":"d46ik5kl73s0","created":1726368502840,"text":"软件架构的演化","layout":null,"note":"架构的关键就是组件 连接件 约束，架构的演化的就是这三个的变化","expandState":"expand"},"children":[{"data":{"id":"d4btnq5h2lk0","created":1726907614723,"text":"面向对象软件架构演化"},"children":[{"data":{"id":"d4btv0j9l8g0","created":1726908185874,"text":"对象演化","note":"对象相关接口的改变"},"children":[]},{"data":{"id":"d4btvbq1sgg0","created":1726908210229,"text":"消息演化"},"children":[]},{"data":{"id":"d4btvqfc8qo0","created":1726908242233,"text":"复合片段演化"},"children":[]},{"data":{"id":"d4btvu95ycg0","created":1726908250567,"text":"约束演化"},"children":[]}]},{"data":{"id":"d4btwk4h7ls0","created":1726908306880,"text":"软件架构演化原则","layout_left_offset":{"x":26,"y":2},"note":"演化成本控制原则\n进度可控原则\n风险可控原则\n主体维持原则\n。。。\n"},"children":[]},{"data":{"id":"d4bu5lbhl1c0","created":1726909014758,"text":"演化实例","note":"1单体架构，一个服务器即可完成\n2 垂直架构:将应用与数据分离，三台服务器，应用服务器，文件服务器，数据库服务器\n3使用缓存改善性能\n4 使用服务器集群改善网站并发处理能力。应用服务器集群是可伸缩架构中较为成熟的一种\n5数据库读写分离\n6使用反向代理和CDNA加速网站响应\n基本原理都是缓存，直接在反向代理服务器中把数据返还给用户，一方面加快用户访问速度，一方面缓解后端服务器压力\n7使用分布式数据库\n8 使用NoSQL和搜索引擎\n9业务拆分\n10 分布式服务\n"},"children":[]}]},{"data":{"id":"d46ikizf3dk0","created":1726368532035,"text":"论系统架构评估","layout":null},"children":[{"data":{"id":"d46p6a5t0480","created":1726387163501,"text":"系统架构评估方法"},"children":[{"data":{"id":"d46p93x3u1s0","created":1726387385007,"text":"SAAm"},"children":[]},{"data":{"id":"d46p97gx42o0","created":1726387392735,"text":"ATAM"},"children":[]},{"data":{"id":"d46p9ffjmsg0","created":1726387410066,"text":"CBAM"},"children":[]}]},{"data":{"id":"d46p7xqlicg0","created":1726387293188,"text":"关键概念：敏感点和权衡点，风险承担者，场景"},"children":[]},{"data":{"id":"d46p8l4ze2w0","created":1726387344124,"text":"分支主题"},"children":[]}]},{"data":{"id":"d46l4b782uw0","created":1726375724595,"text":"软件架构维护","layout":null},"children":[{"data":{"id":"d4b0iiw0btk0","created":1726825394905,"text":"评估方法"},"children":[{"data":{"id":"d4b0m0tbgt40","created":1726825669017,"text":"(1)基于调查问卷或检查表的方法"},"children":[]},{"data":{"id":"d4b0m6fo4pk0","created":1726825681252,"text":"(2)基于场景的评估方法","note":"基于场景的方式由卡耐基梅隆大学软件工程研究所首先提出\n并应用在架构权衡分析法 (Architecture Tradeoff Analysis Method,ATAM) 和软件架构分析方法\n(Software ArchitectureAnalysis Method,SAAM)"},"children":[]},{"data":{"id":"d4b0n2jbsjk0","created":1726825751131,"text":"基于度量的评估方法"},"children":[]}]}]},{"data":{"id":"d4bugm86ll40","created":1726909878740,"text":"自己可以写的项目"},"children":[{"data":{"id":"d4bugxrhytk0","created":1726909903853,"text":"几何内核开发","note":"背景：\n几何内核是一个专门用于处理三维几何体的软件库，它提供了一系列基本的几何操作和算法。\n几何内核的主要作用包括：\n\n处理三维几何体的创建、修改和分析\n提供基本的几何操作，如点、线、面和体的创建和操纵\n实现几何体间的关系和约束\n支持几何体的转换和导出\n\n几何内核独立，对标世界上最先进的几何内核。\n提供基本的模型创建，修改，导入导出，\n几何渲染，事务，持久化，日志，应用开发框架功能。支持windows linux平台下kaifa"},"children":[{"data":{"id":"d4buh7bs6nc0","created":1726909924671,"text":"分层架构","note":"基础工具层\n几何算法层\n数据持久化层\n\napi模块\n应用层，cad demo\n\n渲染模块，错误处理模块，数据同步模块，内存泄露检测模块\n"},"children":[]},{"data":{"id":"d4buhar2mqo0","created":1726909932125,"text":"客户端服务端架构","note":"注册获取授权\n几何内核授权码，几何内核模块检测\n登录模块\n文件服务器：后端记录下载情况，使用情况"},"children":[]},{"data":{"id":"d4buholyyhs0","created":1726909962292,"text":"设计模式","note":"单例\n工厂\n消息机制\n原型"},"children":[]},{"data":{"id":"d4buiewfuu00","created":1726910019521,"text":"基于构件的软件开发","note":"基于原有的几何模型，数据库模块\n"},"children":[]},{"data":{"id":"d4bupbg40q80","created":1726910560553,"text":"面向对象架构","note":"brep topo 几何\n将功能内化到对象基类当中，\n持久化，undo、rodo\n"},"children":[]},{"data":{"id":"d4buq8rogts0","created":1726910633086,"text":"主程序、子程序","note":"几何内核集成之后，调用相应的服务平台，获取数据，如网格需要的网格剖分功能，移文件的形式进行交流"},"children":[]},{"data":{"id":"d4burg2cfsw0","created":1726910727333,"text":"持续集成","note":"1单元测试，测试几何内核的功能与api表现，\n引入了linux测试的流水线，devOps，保证在不同环境下内核功能正确性。"},"children":[]},{"data":{"id":"d4bvk2yjs7c0","created":1726912971366,"text":"批处理","note":"建模算法"},"children":[]}]},{"data":{"id":"d4buh1nce2o0","created":1726909912309,"text":"仿真平台开发"},"children":[{"data":{"id":"d4buhk70az40","created":1726909952680,"text":"分层架构"},"children":[]},{"data":{"id":"d4bv6wjabm00","created":1726911938648,"text":"虚拟机风格","note":"材料库支持表达式，表达的解释"},"children":[]}]}]},{"data":{"id":"d4bvitiqoew0","created":1726912872455,"text":"写法","note":"准备好项目\nhttps://www.bilibili.com/video/BV13K41187VG/?spm_id_from=333.337.search-card.all.click&vd_source=cede8df3811964d3451afc6a064a7930\n套各个方面，往上写你的论点，比如考到架构风格，就去套 分层架构模式，虚拟机架构模式，解释器这种\n\n准备三个 \n就三个"},"children":[{"data":{"id":"d4bvpwoqnh40","created":1726913427897,"text":"软件架构风格"},"children":[]},{"data":{"id":"d4bvzc3gqd40","created":1726914166716,"text":"微服务"},"children":[{"data":{"id":"d4bvzkiv34o0","created":1726914185062,"text":"技术异构性"},"children":[]},{"data":{"id":"d4bvzqthheo0","created":1726914198765,"text":"按照业务拆分"},"children":[]},{"data":{"id":"d4bvzvdsago0","created":1726914208699,"text":"独立部署"},"children":[]}]},{"data":{"id":"d4bw08z6kbk0","created":1726914238291,"text":"设计模式","expandState":"expand"},"children":[{"data":{"id":"d4bw0bac83s0","created":1726914243319,"text":"观察者模式"},"children":[]},{"data":{"id":"d4bw0fxeaoo0","created":1726914253421,"text":"策略模式","note":"算法的封装"},"children":[]},{"data":{"id":"d4bw0ow43rk0","created":1726914272934,"text":"代理模式"},"children":[]}]},{"data":{"id":"d4bw11whca00","created":1726914301255,"text":"需求获取"},"children":[{"data":{"id":"d4bw178hdw80","created":1726914312864,"text":"情节串联板"},"children":[]},{"data":{"id":"d4bw1i302kw0","created":1726914336477,"text":"客户访谈"},"children":[]},{"data":{"id":"d4bw1n0aic00","created":1726914347197,"text":"联合需求策划会议"},"children":[]}]},{"data":{"id":"d4bw1zs3oc00","created":1726914375000,"text":"分层"},"children":[{"data":{"id":"d4bw22799400","created":1726914380270,"text":"分支主题"},"children":[]}]},{"data":{"id":"d4bw26ah5j40","created":1726914389172,"text":"面向对象的分析与设计"},"children":[{"data":{"id":"d4bw2je3cm80","created":1726914417689,"text":"用例图"},"children":[]},{"data":{"id":"d4bw2lo8ieo0","created":1726914422656,"text":"类图"},"children":[]},{"data":{"id":"d4bw2ruzo1k0","created":1726914436125,"text":"时序图"},"children":[]}]},{"data":{"id":"d4bw3q5toog0","created":1726914510791,"text":"可靠性"},"children":[]}]},{"data":{"id":"d4el4n4m9m80","created":1727188230213,"text":"软件设计方法"},"children":[{"data":{"id":"d4elj1ovdzc0","created":1727189359010,"text":"结构化设计方法"},"children":[{"data":{"id":"d4ftlxlqgdk0","created":1727313714042,"text":"提高组件合理性准则","note":"分解与抽象\n模块独立性\n信息隐蔽等"},"children":[]},{"data":{"id":"d4ftmm18atk0","created":1727313767222,"text":"生命周期阶段","note":"结构化分析：结构化分析方法一般利用图形表达用户需求，使用的手段有数据流图，数据字典，结构化语言，判定表，判定树等\n\n结构化设计是一种面向数据流的设计方法，分为概要设计和详细设计两个阶段。\n以SA阶段产生的数据流图和数据字典等文档为基础，是一个自顶向下，逐步求精和模块化的过程\n\n结构化编程："},"children":[]}]},{"data":{"id":"d4elj5ae8400","created":1727189366842,"text":"面向对象设计方法"},"children":[{"data":{"id":"d4ftya7d0140","created":1727314681841,"text":"定义","note":"以用例为驱动的，体系结构为中心的，迭代和渐增的开发过程。\n信息系统的表述与客观实体相对应，符合人们思维，有利于开发人员和用户的交流"},"children":[]},{"data":{"id":"d4fu0ffruhs0","created":1727314849962,"text":"阶段","note":"需求分析\n系统分析\n系统设计\n系统实现\n"},"children":[]}]},{"data":{"id":"d4elj9g85cw0","created":1727189375902,"text":"原型设计方法"},"children":[{"data":{"id":"d4ftru9c2540","created":1727314176947,"text":"定义","note":"根据用户需求，利用系统开发工具，快速建立一个系统模型给用户，在此基础上与用户交流，最终实现用户需求的信息系统快速开发的方法。\n"},"children":[]},{"data":{"id":"d4ftt72usw80","created":1727314283217,"text":"分类","note":"水平原型：也称行为原型，用来探索预期系统的行为，一般用在界面上\n垂直原型：主要用在复杂的算法上，\n\n从原型的结果上分，可以分为抛弃式原型和演化式原型"},"children":[]}]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}