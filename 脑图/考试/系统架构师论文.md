# 系统架构师论文

## 软件架构风格

### 数据流体系架构风格

#### 批处理风格

    每一部都是一个单独的程序，每一步必须在前一步结束之后才能开始，数据必须是完整的，以整体的方式进行传递
优点：高吞吐量，适合大规模数据处理
可以进行全局优化 充分利用资源
易于编程，适合复杂计算

缺点
相应时间长，不适合处理实时需求
不适合处理交互式应用
需要处理大量数据时，需要大内存和计算资源


#### 管道过滤器风格

数据流连接，一个步骤的输出是另一个步骤的输入。
优点
低延迟，可以处理实时应用
可以按需处理数据，节约资源
支持无限数据流，适用于流式处理数据

缺点
处理复杂逻辑需要额外编程
不适合于离线数据分析和大规模批处理
难以进行全局优化

### 调用返回体系结构风格

#### 主程序/子程序风格

优点
代码可以分解为小的可以复用的部分
易于理解和维护
支持代码重用，减少代码冗余

缺点
可能存在全局变量和共享状态，导致潜在的副作用
难以处理负责的数据流和并发

#### 面向对象体系风格

优点
封装性好
继承和多态支持代码重用和扩展
易于处理复杂的数据结构和关系
缺点
面向对象设计需要深思熟虑，不适合所有问题
对象和方法的调用需要额外开销


#### 层次型体系风格

优点
分层结构清晰，易于维护和扩展
支持模块化开发，不同层次可以独立开发测试
适合构件大型系统和分布式系统
缺点
可能存在性能开销，因为数据要穿过多个层次
需要精心设计层次和接口，否则会引入复杂性


#### 客户端/服务端 体系结构风格

### 以数据为中心的体系结构风格

#### 仓库体系结构风格

数据一致性
高效的检索
数据共享 
缺点
复杂性
性能限制


#### 黑板体系结构风格

分布式协作：黑板系统允许多个组件以分布式方式共同解决复杂问题。
2. 灵活性：适用于需要多个专家领域知识的问题。
3. 增量处理：问题可以被分解为多个子问题，逐步解决。

缺点
额外开销
需要复杂的冲突解决策略

### 虚拟机体系风格

#### 解释器风格

使用解释器来执行源代码，而不是将代码编译成机器码
 优点
 跨平台性：解释器通常不依赖于底层硬件
 灵活性：支持动态语言和运行时修改代码
 易于调试和开发
 缺点
 性能较低
 不适合高性能大规模应用
 

#### 规则系统

基于规则的系统使用一系列规则和条件来决定程序的行为。

灵活
自动化 
易于调试

缺点
复杂性：管理大量规则和条件变得复杂


### 独立构件体系结构风格

#### 进程通信体系风格

构件是独立的进程，连接件是消息传递

优点
高度隔离，一个组件故障不会影响整个系统
可以利用多核资源提高性能
适用于大规模，分布式系统
缺点
开销大
复杂性高


#### 事件系统体系结构风格

基于事件的隐式调用风格的思想是构件不直接调用一个过程，而是触发或者广播一个或者多个事件。系统其他构件注册这个事件，事件触发，系统自动调用所有注册的过程。

优点
松散耦合，组件之间相互独立
支持异步和非阻塞操作
易于实现观察者模式和回调机制
缺点
难以追踪事件流
处理复杂的业务模型时，事件驱动模型可能变得负责。

## 基于架构的软件开发方法

架构与体系结构具有相同的含义

### 需求分析阶段

1 如何根据需求模型构件SA模型
2 如何保证模型转换的可追踪性

需求模型到SA模型，从问题空间到解空间

### 设计阶段

SA的基本概念：即SA由哪些元素组成，这些元素之间按照何种原则组织


#### SA的基本概念

#### 体系结构描述语言

支持构件，连接子，及其配置的描述yu'yan

#### SA模型的多视图表示

从不同的视角描述特定系统的体系结构，典型的视图包括4+1视图
逻辑视图，进程视图，开发视图，物理视图+统一的场景


### 实现阶段

1研究基于SA的开发过程支持，如项目组织结构，配置管理
2寻求SA向实现过渡的途径，如将程序设计语言元素引入SA阶段，模型映射，构件组装，复用中间件平台等
3研究基于SA的测试技术

### 构件组装阶段

在SA设计模型的指导下，可复用构件的组装可以在较高层次上实现系统，并能够提高系统实现的效率。
研究内容主要两个方面
1如何支持可复用构件的互联
2在组装过程中，如何检测体系结构失配问题


### 部署阶段

SA对部署的作用如下：
1提供高层的体系结构视图来描述部署阶段的软硬件模型
2基于SA模型可以分析部署方案的质量属性，从而选择合理的部署方案。

### 后开发阶段

SA研究主要围绕维护，演化，复用等方面来进行 

### ASBD

基于架构的软件设计

1设计元素
ASBD 是自顶向下，逐步细化的方法，系统被分解称为子系统和软件模板


2 视角和视图
3 用例和质量场景

####  基于体系的开发模型

传统的软件开发过程被划分为问题定义，需求分析，软件设计，软件实现，软件测试
基于体系的开发模型把软件过程划分为体系结构需求，设计，文档化，复审，实现 演化

需求阶段：用例图和类图
需求获取过程主要是定义开发人员必须要实现的软件功能
，一般来源于三个方面，分别是系统的质量目标，系统的商业目标，系统开发人员的商业目标

标识构件：1 生成类图 2对类进行分组 3 把类打包成构件

架构需求评审


##### 体系结构设计

1提出软件体系结构模型
2将已经标识的构件映射到软件体系结构中
3分析构件之间的相互作用
4产生软件体系结构
5设计评审

##### 架构文档化

对架构设计进行分析和整理，生成架构规格说明书和测试架构需求的质量设计说明说

##### 架构复审

在主版本的软件架构分析之后，安排一次由外部人员参加的架构复审，架构复审主要判断架构是否能够满足需求，质量属性是否能够在架构中得以体现，层次是否清晰，模块划分是否合理。
从而标识潜在的风险，及早发现架构设计中的缺陷和错误。

##### 体系结构实现

以复审后的文档化的体系结构说明书为基础，以下步骤
1分析与设计
2构件实现
3构件组装
4系统测试

##### 架构演化阶段

主要目的是解决系统开发过程中发生的需求变更问题。
1需求变化归类
2指定体系结构演化计划
3修改，增加或者删除构件
4更新构件的相互作用
5构件的组装与测试
6技术评审

## 基于构件的软件开发方法

### 定义

体现了购买而不是重新构造

### 特征

可组装性：所有外部交互必须通过公开定义的接口进行
可部署性：构件总是二进制形式的，能作为一个独立实体在平台上运行。
文档化：用户通过文档来判断是否满足要求
独立性：可以在无其它构件的情况下独立部署
标准化：符合某种标准化的构件模型	

### 基于构件的开发过程

1 系统需求概览
2

## 软件架构的演化

架构的关键就是组件 连接件 约束，架构的演化的就是这三个的变化

### 面向对象软件架构演化

#### 对象演化

对象相关接口的改变

#### 消息演化

#### 复合片段演化

#### 约束演化

### 软件架构演化原则

演化成本控制原则
进度可控原则
风险可控原则
主体维持原则
。。。


### 演化实例

1单体架构，一个服务器即可完成
2 垂直架构:将应用与数据分离，三台服务器，应用服务器，文件服务器，数据库服务器
3使用缓存改善性能
4 使用服务器集群改善网站并发处理能力。应用服务器集群是可伸缩架构中较为成熟的一种
5数据库读写分离
6使用反向代理和CDNA加速网站响应
基本原理都是缓存，直接在反向代理服务器中把数据返还给用户，一方面加快用户访问速度，一方面缓解后端服务器压力
7使用分布式数据库
8 使用NoSQL和搜索引擎
9业务拆分
10 分布式服务


## 论系统架构评估

### 系统架构评估方法

#### SAAm

#### ATAM

#### CBAM

### 关键概念：敏感点和权衡点，风险承担者，场景

### 分支主题

## 软件架构维护

### 评估方法

#### (1)基于调查问卷或检查表的方法

#### (2)基于场景的评估方法

基于场景的方式由卡耐基梅隆大学软件工程研究所首先提出
并应用在架构权衡分析法 (Architecture Tradeoff Analysis Method,ATAM) 和软件架构分析方法
(Software ArchitectureAnalysis Method,SAAM)

#### 基于度量的评估方法

## 自己可以写的项目

### 几何内核开发

背景：
几何内核是一个专门用于处理三维几何体的软件库，它提供了一系列基本的几何操作和算法。
几何内核的主要作用包括：

处理三维几何体的创建、修改和分析
提供基本的几何操作，如点、线、面和体的创建和操纵
实现几何体间的关系和约束
支持几何体的转换和导出

几何内核独立，对标世界上最先进的几何内核。
提供基本的模型创建，修改，导入导出，
几何渲染，事务，持久化，日志，应用开发框架功能。支持windows linux平台下kaifa

#### 分层架构

基础工具层
几何算法层
数据持久化层

api模块
应用层，cad demo

渲染模块，错误处理模块，数据同步模块，内存泄露检测模块


#### 客户端服务端架构

注册获取授权
几何内核授权码，几何内核模块检测
登录模块
文件服务器：后端记录下载情况，使用情况

#### 设计模式

单例
工厂
消息机制
原型

#### 基于构件的软件开发

基于原有的几何模型，数据库模块


#### 面向对象架构

brep topo 几何
将功能内化到对象基类当中，
持久化，undo、rodo


#### 主程序、子程序

几何内核集成之后，调用相应的服务平台，获取数据，如网格需要的网格剖分功能，移文件的形式进行交流

#### 持续集成

1单元测试，测试几何内核的功能与api表现，
引入了linux测试的流水线，devOps，保证在不同环境下内核功能正确性。

#### 批处理

建模算法

### 仿真平台开发

#### 分层架构

#### 虚拟机风格

材料库支持表达式，表达的解释

## 写法

准备好项目
https://www.bilibili.com/video/BV13K41187VG/?spm_id_from=333.337.search-card.all.click&vd_source=cede8df3811964d3451afc6a064a7930
套各个方面，往上写你的论点，比如考到架构风格，就去套 分层架构模式，虚拟机架构模式，解释器这种

准备三个 
就三个

### 软件架构风格

### 微服务

#### 技术异构性

#### 按照业务拆分

#### 独立部署

### 设计模式

#### 观察者模式

#### 策略模式

算法的封装

#### 代理模式

### 需求获取

#### 情节串联板

#### 客户访谈

#### 联合需求策划会议

### 分层

#### 分支主题

### 面向对象的分析与设计

#### 用例图

#### 类图

#### 时序图

### 可靠性

## 软件设计方法

### 结构化设计方法

#### 提高组件合理性准则

分解与抽象
模块独立性
信息隐蔽等

#### 生命周期阶段

结构化分析：结构化分析方法一般利用图形表达用户需求，使用的手段有数据流图，数据字典，结构化语言，判定表，判定树等

结构化设计是一种面向数据流的设计方法，分为概要设计和详细设计两个阶段。
以SA阶段产生的数据流图和数据字典等文档为基础，是一个自顶向下，逐步求精和模块化的过程

结构化编程：

### 面向对象设计方法

#### 定义

以用例为驱动的，体系结构为中心的，迭代和渐增的开发过程。
信息系统的表述与客观实体相对应，符合人们思维，有利于开发人员和用户的交流

#### 阶段

需求分析
系统分析
系统设计
系统实现


### 原型设计方法

#### 定义

根据用户需求，利用系统开发工具，快速建立一个系统模型给用户，在此基础上与用户交流，最终实现用户需求的信息系统快速开发的方法。


#### 分类

水平原型：也称行为原型，用来探索预期系统的行为，一般用在界面上
垂直原型：主要用在复杂的算法上，

从原型的结果上分，可以分为抛弃式原型和演化式原型
